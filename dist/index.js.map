{"version":3,"sources":["../index.js"],"names":["deepMergeObjects","objectOld","objectNew","recurseMerge","oldKeys","newKeys","Object","keys","reduce","obj","key","newItem","oldItem","Array","isArray","mergeBy","items","newItems","keyOrCallback","mergeDeep","filter","e","comparitor","item","matchedIndexes","combined","map","matchedIndex","findIndex","push","concat","i","indexOf"],"mappings":";;;;;;;;;;AAAA;;;;;;;AAOA,IAAMA,mBAAmB,SAAnBA,gBAAmB,CAACC,SAAD,EAAYC,SAAZ,EAA0B;AAC/C,QAAMC,eAAe,SAAfA,YAAe,CAACC,OAAD,EAAUC,OAAV,EAAsB;AACvC,eAAOC,OAAOC,IAAP,CAAYF,OAAZ,EAAqBG,MAArB,CAA4B,UAACC,GAAD,EAAMC,GAAN,EAAc;AAC7C,gBAAMC,UAAUN,QAAQK,GAAR,CAAhB;AACA,gBAAME,UAAUR,QAAQM,GAAR,CAAhB;AACA,gBAAI,QAAOC,OAAP,yCAAOA,OAAP,OAAmB,QAAnB,IAA+B,QAAOC,OAAP,yCAAOA,OAAP,OAAmB,QAAlD,IACD,CAACC,MAAMC,OAAN,CAAcH,OAAd,CADA,IAC0B,CAACE,MAAMC,OAAN,CAAcF,OAAd,CAD/B,EACuD;AACnDH,oBAAIC,GAAJ,iBACON,QAAQM,GAAR,CADP,EAEOP,aAAaS,OAAb,EAAsBD,OAAtB,CAFP;AAIH,aAND,MAMO;AACHF,oBAAIC,GAAJ,IAAWC,OAAX;AACH;AACD,mBAAOF,GAAP;AACH,SAbM,EAaJ,EAbI,CAAP;AAcH,KAfD;;AAiBA,wBACOR,SADP,EAEOE,aAAaF,SAAb,EAAwBC,SAAxB,CAFP;AAIH,CAtBD;;AAwBA;;;;;;;;;AASA,IAAMa,UAAU,SAAVA,OAAU,CAACC,KAAD,EAAQC,QAAR,EAAkBC,aAAlB,EAAuD;AAAA,QAAtBC,SAAsB,uEAAV,KAAU;;AACnE;AACA,QAAG,CAACN,MAAMC,OAAN,CAAcG,QAAd,CAAJ,EAA6B;AACzBA,mBAAW,CAACA,QAAD,EAAWG,MAAX,CAAkB;AAAA,mBAAKC,CAAL;AAAA,SAAlB,CAAX,CADyB,CACa;AACzC;;AAED,QAAMC,aAAa,OAAOJ,aAAP,KAAyB,UAAzB,GACbA,aADa,GAEb,UAACK,IAAD,EAAOZ,OAAP;AAAA,eAAmBY,KAAKL,aAAL,MAAwBP,QAAQO,aAAR,CAA3C;AAAA,KAFN;;AAIA,QAAMM,iBAAiB,EAAvB;AACA,QAAMC,WAAWT,MAAMU,GAAN,CAAU,UAACH,IAAD,EAAU;AACjC,YAAMI,eAAeV,SAASW,SAAT,CAAmB;AAAA,mBAAWN,WAAWC,IAAX,EAAiBZ,OAAjB,CAAX;AAAA,SAAnB,CAArB;;AAEA,YAAIgB,iBAAiB,CAAC,CAAtB,EAAyB;AACrB,mBAAOJ,IAAP;AACH;AACDC,uBAAeK,IAAf,CAAoBF,YAApB;;AAEA,YAAIR,SAAJ,EAAe;AACX,mBAAOnB,iBAAiBuB,IAAjB,EAAuBN,SAASU,YAAT,CAAvB,CAAP;AACH;;AAED,4BACOJ,IADP,EAEON,SAASU,YAAT,CAFP;AAIH,KAhBgB,CAAjB;;AAkBA;AACA,WAAOF,SAASK,MAAT,CACHb,SAASG,MAAT,CAAgB,UAACC,CAAD,EAAIU,CAAJ;AAAA,eAAUP,eAAeQ,OAAf,CAAuBD,CAAvB,MAA8B,CAAC,CAAzC;AAAA,KAAhB,CADG,CAAP;AAGH,CAjCD;;kBAmCehB,O","file":"index.js","sourcesContent":["/**\n * deepMergeObjects\n * Recursively merge nested objects\n * @param {Object} objectOld\n * @param {Object} objectNew\n * @returns {Object}\n */\nconst deepMergeObjects = (objectOld, objectNew) => {\n    const recurseMerge = (oldKeys, newKeys) => {\n        return Object.keys(newKeys).reduce((obj, key) => {\n            const newItem = newKeys[key]\n            const oldItem = oldKeys[key]\n            if (typeof newItem === 'object' && typeof oldItem === 'object'\n            && !Array.isArray(newItem) && !Array.isArray(oldItem)) {\n                obj[key] = {\n                    ...oldKeys[key],\n                    ...recurseMerge(oldItem, newItem),\n                };\n            } else {\n                obj[key] = newItem;\n            }\n            return obj;\n        }, {});\n    };\n\n    return {\n        ...objectOld,\n        ...recurseMerge(objectOld, objectNew),\n    };\n};\n\n/**\n * mergeBy\n * Merge two arrays of objects\n * @param {Array.<Object>} items\n * @param {Array.<Object>} newItems\n * @param {Function|String} keyOrCallback\n * @param {boolean} [mergeDeep=false]\n * @returns {Array.<Object>}\n */\nconst mergeBy = (items, newItems, keyOrCallback, mergeDeep = false) => {\n    // Ensure newItems is array - object could also be passed\n    if(!Array.isArray(newItems)) {\n        newItems = [newItems].filter(e => e); // Filter undefined/null\n    }\n\n    const comparitor = typeof keyOrCallback === 'function' \n        ? keyOrCallback \n        : (item, newItem) => item[keyOrCallback] === newItem[keyOrCallback]\n\n    const matchedIndexes = [];\n    const combined = items.map((item) => {\n        const matchedIndex = newItems.findIndex(newItem => comparitor(item, newItem));\n\n        if (matchedIndex === -1) {\n            return item;\n        }\n        matchedIndexes.push(matchedIndex);\n\n        if (mergeDeep) {\n            return deepMergeObjects(item, newItems[matchedIndex]);\n        }\n\n        return {\n            ...item,\n            ...newItems[matchedIndex],\n        };\n    });\n\n    // Add unmerged items to the end of the array\n    return combined.concat(\n        newItems.filter((e, i) => matchedIndexes.indexOf(i) === -1)\n    )\n};\n\nexport default mergeBy;\n"]}